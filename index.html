<!doctype html>
<html lang="ja">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>ãƒ—ãƒ©ãƒãƒŠå“ç®¡ç†ãƒ„ãƒ¼ãƒ«</title>
	<link rel="icon" href="ã‚¢ã‚¤ã‚³ãƒ³.png" type="image/png">
	<link rel="stylesheet" href="assets/style.css">
</head>

<body>
	<div class="app">
		<header>
			<div class="brand">
				<div id="headerStatus" class="header-status"></div>
			</div>

			<div class="controls">
				<button class="btn ghost" id="btnPrev">â—€ å‰æ—¥</button>
				<div class="field" title="å–¶æ¥­æ—¥">
					<input type="date" id="datePicker" />
				</div>
				<button class="btn ghost" id="btnNext">ç¿Œæ—¥ â–¶</button>
				<button class="btn ghost" id="btnToday">ä»Šæ—¥</button>
				<button class="btn primary" id="btnNew">ï¼‹ æ–°è¦</button>
			</div>
		</header>

		<div class="grid">
			<section class="floor">
				<div class="seat-grid">
					<div class="zone box2" data-seat="BOX2">
						<div class="zone-title">BOX2</div>
						<div class="drop" id="seat-BOX2"></div>
					</div>

					<div class="zone box3" data-seat="BOX3">
						<div class="zone-title">BOX3</div>
						<div class="drop" id="seat-BOX3"></div>
					</div>

					<div class="zone box1" data-seat="BOX1">
						<div class="zone-title">BOX1</div>
						<div class="drop" id="seat-BOX1"></div>
					</div>

					<div class="counter-row">
						<div class="zone counter" data-seat="C1">
							<div class="zone-title">C1</div>
							<div class="drop" id="seat-C1"></div>
						</div>
						<div class="zone counter" data-seat="C2">
							<div class="zone-title">C2</div>
							<div class="drop" id="seat-C2"></div>
						</div>
						<div class="zone counter" data-seat="C3">
							<div class="zone-title">C3</div>
							<div class="drop" id="seat-C3"></div>
						</div>
						<div class="zone counter" data-seat="C4">
							<div class="zone-title">C4</div>
							<div class="drop" id="seat-C4"></div>
						</div>
						<div class="zone counter" data-seat="C5">
							<div class="zone-title">C5</div>
							<div class="drop" id="seat-C5"></div>
						</div>
						<div class="zone counter" data-seat="C6">
							<div class="zone-title">C6</div>
							<div class="drop" id="seat-C6"></div>
						</div>
					</div>
				</div>
			</section>

			<section class="panel">
				<div class="panel-head">
					<div class="ttl">ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ï¼ˆå—ä»˜è¡¨ï¼‰</div>
					<div class="right">
						<input class="search" id="search" placeholder="åå‰æ¤œç´¢ï¼ˆä¾‹ï¼šä½è—¤ï¼‰" />
						<button class="btn ghost" id="btnSortEnd">çµ‚äº†æ™‚é–“é †</button>
					</div>
				</div>

				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>No</th>
								<th>ç´¯è¨ˆ</th>
								<th>å“ç•ª</th>
								<th>åŒºåˆ†</th>
								<th>ãŠå®¢æ§˜å</th>
								<th>äººæ•°</th>
								<th>å…¥åº—</th>
								<th>é€€åº—</th>
								<th>å»¶é•·</th>
								<th>çŠ¶æ…‹</th>
							</tr>
						</thead>
						<tbody id="tbody"></tbody>
					</table>
				</div>
			</section>
		</div>
	</div>

	<!-- æ–°è¦/ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
	<dialog id="dlg">
		<div class="modal">
			<div class="mhead">
				<div class="mttl" id="dlgTitle">æ–°è¦å“</div>
				<button class="closeX" id="dlgClose">âœ•</button>
			</div>

			<!-- ç·¨é›†æ™‚ã®ã¿è¡¨ç¤ºï¼šå»¶é•·ãƒ¯ãƒ³ã‚¿ãƒƒãƒ— + é€€åº— -->
			<div class="extbar" id="extbar" style="display:none;">
				<div class="extbtns">
					<button type="button" class="extbtn" data-min="30">+30</button>
					<button type="button" class="extbtn" data-min="60">+60</button>
					<button type="button" class="extbtn" data-min="90">+90</button>
					<button type="button" class="extbtn" data-act="close">é€€åº—</button>
				</div>

				<div class="metrics">
					<div class="metric" id="mRem">æ®‹--åˆ†</div>
					<div class="metric" id="mElp">çµŒé--åˆ†</div>
				</div>
			</div>

			<div class="form">
				<div class="fg">
					<label>ãŠå®¢æ§˜åï¼ˆç©ºã§ã‚‚OKï¼‰</label>
					<input id="fName" placeholder="ä¾‹ï¼šãŸãªã‹ æ§˜" />
				</div>

				<div class="fg">
					<label>ä¼ç¥¨No</label>
					<input id="fNo" type="number" min="1" step="1" />
				</div>

				<div class="fg full">
					<label>åŒºåˆ¥</label>
					<div class="typebar" id="typebar">
						<button type="button" class="typebtn" data-type="new">æ–°è¦</button>
						<button type="button" class="typebtn" data-type="repeat">ãƒªãƒ”ãƒ¼ã‚¿ãƒ¼</button>
						<button type="button" class="typebtn" data-type="unknown">ä¸æ˜</button>
					</div>
				</div>

				<div class="fg full">
					<label>ä½¿ç”¨å¸­ï¼ˆã‚¿ãƒƒãƒ—ã§ON/OFFï¼‰</label>
					<div class="seatpick" id="seatPick"></div>
					<div class="td-muted" style="font-size:12px;">
						â€» æœ¬ä½“ã‚«ãƒ¼ãƒ‰ã¯ã€Œå“ç•ªã€ã§é¸ã‚“ã å¸­ã«ç½®ãã¾ã™ï¼ˆä»–ã¯ã‚¹ã‚¿ãƒ³ãƒ—è¡¨ç¤ºï¼‰
					</div>
				</div>

				<div class="fg">
					<label>äººæ•°</label>
					<input id="fParty" type="number" min="1" max="20" value="1" />
				</div>

				<div class="fg">
					<label>å“ç•ªï¼ˆæœ¬ä½“ã‚«ãƒ¼ãƒ‰ä½ç½®ï¼‰</label>
					<select id="fSeat"></select>
				</div>

				<div class="fg">
					<label>å…¥åº—ï¼ˆä¿å­˜æ™‚ã«5åˆ†åˆ»ã¿ã«è£œæ­£ï¼‰</label>
					<input id="fIn" type="time" step="300" />
				</div>

				<div class="fg">
					<label>é€€åº—äºˆå®šï¼ˆèª¿æ•´OKï¼‰</label>
					<input id="fDue" type="time" step="300" />
					<div class="td-muted" style="font-size:12px;">
						â€»å¤‰æ›´ã™ã‚‹ã¨å»¶é•·åˆè¨ˆã‚’è‡ªå‹•èª¿æ•´ï¼ˆ30åˆ†å˜ä½ï¼‰
					</div>
				</div>

				<div class="fg full">
					<label>ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰</label>
					<input id="fNote" placeholder="ä¾‹ï¼šå›£ä½“ï¼æ­ŒOK ãªã©" />
				</div>
			</div>

			<div class="mfoot">
				<button class="btn ghost" id="dlgDelete">å‰Šé™¤</button>
				<button class="btn ghost" id="dlgCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
				<button class="btn primary" id="dlgSave">ä¿å­˜</button>
			</div>
		</div>
	</dialog>

	<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

	<script>
		(() => {
			"use strict";

			const SEATS = ["BOX1","BOX2","BOX3","C1","C2","C3","C4","C5","C6"];
			const BASE_MIN = 90;

			// ===== GAS WebApp URLï¼ˆ/execï¼‰=====
			const API_URL = "/api";

			const pad2 = (n) => String(n).padStart(2, "0");

			const toHHMM = (date) => `${pad2(date.getHours())}:${pad2(date.getMinutes())}`;

			const parseHHMMToDate = (hhmm, baseDate) => {
				const [h, m] = hhmm.split(":").map(Number);
				const d = new Date(baseDate);
				d.setHours(h, m, 0, 0);
				return d;
			};

			const roundDown5Min = (date) => {
				const d = new Date(date);
				d.setMinutes(Math.floor(d.getMinutes() / 5) * 5, 0, 0);
				return d;
			};

			const addMinutes = (date, min) => {
				const d = new Date(date);
				d.setMinutes(d.getMinutes() + min);
				return d;
			};

			// 7:00ã‚ˆã‚Šå‰ã¯ â€œå‰æ—¥å–¶æ¥­æ—¥â€
			const businessDateFor = (date) => {
				const d = new Date(date);
				const biz = new Date(d);
				if (biz.getHours() < 7) biz.setDate(biz.getDate() - 1);
				return `${biz.getFullYear()}-${pad2(biz.getMonth()+1)}-${pad2(biz.getDate())}`;
			};

			const nowRounded = () => roundDown5Min(new Date());

			const checkInDateFromHHMM = (hhmm) => {
				const base = new Date(currentBizDate + "T00:00:00");
				let d = parseHHMMToDate(hhmm, base);

				// 0:00ã€œ6:59å…¥åŠ›ã¯ç¿Œæ—¥ã«å¯„ã›ã‚‹ï¼ˆå–¶æ¥­æ—¥å†…ã®æ·±å¤œæƒ³å®šï¼‰
				if (d.getHours() < 7) d.setDate(d.getDate() + 1);

				d = roundDown5Min(d);

				// æœªæ¥ã«é£›ã³ã™ãã‚¬ãƒ¼ãƒ‰ï¼ˆä»Šã®å–¶æ¥­æ—¥ã®ã¨ãã ã‘ï¼‰
				const isCurrentBiz = (currentBizDate === businessDateFor(new Date()));
				if (isCurrentBiz){
					const now = new Date();
					const FUTURE_GUARD_MIN = 12 * 60;
					if ((d - now) > FUTURE_GUARD_MIN * 60000){
						d.setDate(d.getDate() - 1);
						d = roundDown5Min(d);
					}
				}
				return d;
			};

			const escapeHtml = (str) => String(str)
			.replaceAll("&","&amp;")
			.replaceAll("<","&lt;")
			.replaceAll(">","&gt;")
			.replaceAll('"',"&quot;")
			.replaceAll("'","&#039;");

			const elapsedMin = (g, now) => {
				const inDate = new Date(g.checkInAt);
				return Math.max(0, Math.floor((now - inDate) / 60000));
			};

			const totalExtMin = (g) => (g.extends || []).reduce((a, e) => a + (Number(e.min) || 0), 0);

			const dueAt = (g) => addMinutes(new Date(g.checkInAt), BASE_MIN + totalExtMin(g));

			const remainingMin = (g, now) => Math.floor((dueAt(g) - now) / 60000);

			const guestTypeKey = (g) => {
				const v = g?.guestType ?? g?.type ?? g?.customerType ?? g?.kbn ?? "unknown";
				const s = String(v ?? "").trim().toLowerCase();
				return s || "unknown";
			};

			const guestTypeLabel = (g) => {
				const s = guestTypeKey(g);
				if (["new","æ–°è¦","shinki","first","åˆå›","0"].includes(s)) return "æ–°è¦";
				if (["repeat","repeater","ãƒªãƒ”ãƒ¼ã‚¿ãƒ¼","ãƒªãƒ”","1"].includes(s)) return "ãƒªãƒ”ãƒ¼ã‚¿ãƒ¼";
				return "ä¸æ˜";
			};

			const typeShort = (g) => {
				const t = guestTypeKey(g);
				if (t === "new") return "æ–°è¦";
				if (t === "repeat" || t === "repeater") return "ãƒªãƒ”";
				return "ä¸æ˜";
			};

			const isBoxSeat = (seat) => /^BOX[123]$/.test(String(seat || ""));
			const isCounterSeat = (seat) => /^C[1-6]$/.test(String(seat || ""));


			/* ===== Storage (localStorage + Sheets) ===== */
			const storageKey = (bizDate) => `platinum_day_${bizDate}`;

			// Sheets GET
			async function apiGetDay(bizDate){
				const url = `${API_URL}?action=day&bizDate=${encodeURIComponent(bizDate)}`;
				const res = await fetch(url, { method:"GET" });
				const json = await res.json();
				if (!json.ok) throw new Error(json.error || "api error");
				return Array.isArray(json.groups) ? json.groups : [];
			}

			// Sheets POST
			async function apiSaveDay(bizDate, groups){
				const payload = { action:"saveDay", bizDate, groups };

				const res = await fetch(API_URL, {
					method: "POST",
					body: JSON.stringify(payload) // â†ãƒ˜ãƒƒãƒ€ãƒ¼æŒ‡å®šã—ãªã„
				});

				const text = await res.text();
				let json;
				try { json = JSON.parse(text); } catch { throw new Error("Non-JSON: " + text); }
				if (!json.ok) throw new Error(json.error || "api error");
			}

			// load: Sheets â†’ ãƒ€ãƒ¡ãªã‚‰localStorage
			async function loadDay(bizDate){
				try{
					const data = await apiGetDay(bizDate);
					// ã¤ã„ã§ã«ãƒ­ãƒ¼ã‚«ãƒ«ã¸ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆä»»æ„ã ã‘ã©ä¾¿åˆ©ï¼‰
					localStorage.setItem(storageKey(bizDate), JSON.stringify(data));
					return data;
				}catch{
					const raw = localStorage.getItem(storageKey(bizDate));
					if (!raw) return [];
					try{
						const data = JSON.parse(raw);
						return Array.isArray(data) ? data : [];
					}catch{
						return [];
					}
				}
			}

			// save: ã¾ãšãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ï¼ˆä¿é™ºï¼‰â†’ Sheetsã¸é€ä¿¡ï¼ˆå¤±æ•—ã—ã¦ã‚‚UIæ­¢ã‚ãªã„ï¼‰
			function saveDay(bizDate, groups){
				if (isLoadingDay) return;
				localStorage.setItem(storageKey(bizDate), JSON.stringify(groups));

				apiSaveDay(bizDate, groups)
				.then(()=> console.log("âœ… Saved to Sheets"))
				.catch((e)=> console.error("âŒ Save failed", e));
			}


			/* ===== State ===== */
			let currentBizDate = businessDateFor(new Date());
			let groups = [];
			let editingId = null;

			let tempGuestType = "unknown";
			let tempOccupied = new Set();
			let sortByEnd = false;

			// ===== Loading lock =====
			let isLoadingDay = false;

			function setLoadingDay(on){
				isLoadingDay = on;

				// ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
				if (btnNew) btnNew.disabled = on;
				if (dlgSave) dlgSave.disabled = on;

				// â€œèª­ã¿è¾¼ã¿ä¸­â€è¡¨ç¤ºï¼ˆä»»æ„ï¼‰
				if (headerStatus && on){
					headerStatus.innerHTML = `<div class="hs-date">èª­ã¿è¾¼ã¿ä¸­â€¦</div>`;
				}
			}

			/* ===== Ticket No ===== */
			const nextTicketNo = () => {
				const maxNo = groups.reduce((mx, g) => Math.max(mx, Number(g.ticketNo || 0)), 0);
				return maxNo + 1;
			};


			/* ===== Normalize ===== */
			const normalizeGroup = (g) => {
				if (!g.primarySeat) g.primarySeat = g.seatId || "BOX1";

				if (!Array.isArray(g.occupiedSeats)){
					if (typeof g.lastSeatLabel === "string" && g.lastSeatLabel.trim()){
						g.occupiedSeats = g.lastSeatLabel.split("+").filter(Boolean);
					}else{
						g.occupiedSeats = [g.primarySeat];
					}
				}

				if (g.primarySeat && !g.occupiedSeats.includes(g.primarySeat)){
					g.occupiedSeats.unshift(g.primarySeat);
				}

				g.name = (g.name ?? "");
				g.partySize = Number(g.partySize ?? 1);
				g.note = (g.note ?? "");
				g.guestType = String(g.guestType ?? "unknown");

				if (!Array.isArray(g.extends)) g.extends = [];
				g.checkOutAt = g.checkOutAt || null;
				if (!Array.isArray(g.moves)) g.moves = [];

				g.ticketNo = Number(g.ticketNo || 0);

				return g;
			};

			const normalizeAll = () => {
				let touched = false;

				groups = (groups || []).map((x) => {
					const before = JSON.stringify(x);
					const after = normalizeGroup(x);
					if (JSON.stringify(after) !== before) touched = true;
					return after;
				});

				// ticketNo æœªæ¡ç•ª(0)ã‚’ã€å…¥åº—é †ã§é€£ç•ª
				const maxNo = groups.reduce((mx, g) => Math.max(mx, Number(g.ticketNo||0)), 0);
				let seq = maxNo;

				const need = groups
				.filter((g) => !Number(g.ticketNo))
				.sort((a, b) => new Date(a.checkInAt) - new Date(b.checkInAt));

				if (need.length){
					for (const g of need){
						seq += 1;
						g.ticketNo = seq;
					}
					touched = true;
				}

				if (touched) saveDay(currentBizDate, groups);
			};


			/* ===== DOM ===== */
			const datePicker = document.getElementById("datePicker");
			const btnPrev = document.getElementById("btnPrev");
			const btnNext = document.getElementById("btnNext");
			const btnToday = document.getElementById("btnToday");
			const btnNew = document.getElementById("btnNew");
			const headerStatus = document.getElementById("headerStatus");

			const tbody = document.getElementById("tbody");
			const search = document.getElementById("search");
			const btnSortEnd = document.getElementById("btnSortEnd");

			const dlg = document.getElementById("dlg");
			const dlgTitle = document.getElementById("dlgTitle");
			const dlgClose = document.getElementById("dlgClose");
			const dlgCancel = document.getElementById("dlgCancel");
			const dlgSave = document.getElementById("dlgSave");
			const dlgDelete = document.getElementById("dlgDelete");

			const fName = document.getElementById("fName");
			const fParty = document.getElementById("fParty");
			const fSeat = document.getElementById("fSeat");
			const fIn = document.getElementById("fIn");
			const fDue = document.getElementById("fDue");
			const fNote = document.getElementById("fNote");
			const typebar = document.getElementById("typebar");
			const seatPick = document.getElementById("seatPick");
			const extbar = document.getElementById("extbar");
			const fNo = document.getElementById("fNo");


			/* ===== Seat select ===== */
			const initSeatSelect = () => {
				fSeat.innerHTML = "";
				for (const s of SEATS){
					const opt = document.createElement("option");
					opt.value = s;
					opt.textContent = s;
					fSeat.appendChild(opt);
				}
			};
			initSeatSelect();


			/* ===== seatPick ===== */
			const refreshSeatPickUI = () => {
				seatPick.querySelectorAll(".seatchip").forEach((btn) => {
					btn.classList.toggle("on", tempOccupied.has(btn.dataset.seat));
				});
			};

			const buildSeatPick = () => {
				seatPick.innerHTML = "";
				for (const s of SEATS){
					const b = document.createElement("button");
					b.type = "button";
					b.className = "seatchip";
					b.dataset.seat = s;
					b.textContent = s;
					seatPick.appendChild(b);
				}
				refreshSeatPickUI();
			};


			/* ===== Date switch ===== */
			datePicker.value = currentBizDate;

			const setBizDate = async (newDateStr) => {
				currentBizDate = newDateStr;
				datePicker.value = currentBizDate;

				setLoadingDay(true);
				try{
    				groups = await loadDay(currentBizDate);  // â˜…ã“ã“ãŒæœ¬ä½“
					normalizeAll();
					renderAll();
				} finally {
					setLoadingDay(false);
				}
			};

			const addDaysToBizDate = (bizDate, delta) => {
				const d = new Date(bizDate + "T00:00:00");
				d.setDate(d.getDate() + delta);
				return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
			};


			/* ===== CRUD ===== */
			const uid = () => `${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`;

			const seatLabelForArchive = (g) => {
				if (g.lastSeatLabel) return g.lastSeatLabel;
				if (g.lastSeatId) return g.lastSeatId;

				const primary = g.primarySeat || g.seatId || "";
				const occ = Array.isArray(g.occupiedSeats) ? g.occupiedSeats : [];
				const extra = occ.filter((s) => s && s !== primary);
				return [primary, ...extra].filter(Boolean).join("+");
			};

			const closeGroup = (groupId) => {
				const g = groups.find((x) => x.id === groupId);
				if (!g || g.checkOutAt) return;

				g.checkOutAt = nowRounded().toISOString();

				const primary = g.primarySeat || g.seatId || "";
				const occ = Array.isArray(g.occupiedSeats) ? g.occupiedSeats : [];
				const extra = occ.filter((s) => s && s !== primary);
				g.lastSeatLabel = [primary, ...extra].filter(Boolean).join("+");

				g.lastSeatId = g.seatId;
				g.seatId = "ARCHIVE";

				saveDay(currentBizDate, groups);
				renderAll();
			};

			const deleteGroup = (groupId) => {
				const g = groups.find((x) => x.id === groupId);
				if (!g) return;

				const label = (g.name || "æœªå…¥åŠ›");
				if (!confirm(`ã€Œ${label}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå…ƒã«æˆ»ã›ã¾ã›ã‚“ï¼‰`)) return;

				groups = groups.filter((x) => x.id !== groupId);
				saveDay(currentBizDate, groups);
				renderAll();
			};

			const movePrimary = (groupId, newSeat) => {
				const g = groups.find((x) => x.id === groupId);
				if (!g || g.checkOutAt) return;

				const old = g.primarySeat || g.seatId;
				if (old === newSeat) return;

				g.moves = g.moves || [];
				g.moves.push({ from: old, to: newSeat, at: nowRounded().toISOString() });

				const occ = Array.isArray(g.occupiedSeats) ? [...g.occupiedSeats] : [];
				let replaced = false;

				for (let i = 0; i < occ.length; i++){
					if (occ[i] === old){
						occ[i] = newSeat;
						replaced = true;
					}
				}
				if (!replaced) occ.unshift(newSeat);

				const uniq = Array.from(new Set(occ.filter(Boolean)));
				g.occupiedSeats = [newSeat, ...uniq.filter((s) => s !== newSeat)];
				g.primarySeat = newSeat;

				saveDay(currentBizDate, groups);
				renderAll();
			};


			/* ===== Modal helpers ===== */
			const setTypeUI = (t) => {
				tempGuestType = t;
				typebar.querySelectorAll(".typebtn").forEach((b) => {
					b.classList.toggle("on", b.dataset.type === t);
				});
			};

			typebar.addEventListener("click", (e) => {
				const btn = e.target.closest(".typebtn");
				if (!btn) return;
				setTypeUI(btn.dataset.type);
			});

			seatPick.addEventListener("click", (e) => {
				const btn = e.target.closest(".seatchip");
				if (!btn) return;

				const seat = btn.dataset.seat;
				if (!seat) return;

				if (tempOccupied.has(seat)) tempOccupied.delete(seat);
				else tempOccupied.add(seat);

				const primary = fSeat.value;
				if (primary) tempOccupied.add(primary);

				refreshSeatPickUI();
			});

			fSeat.addEventListener("change", () => {
				const primary = fSeat.value;
				if (primary) tempOccupied.add(primary);
				refreshSeatPickUI();
			});

			const openNewDialog = (defaultSeat="BOX1") => {
				editingId = null;
				dlgTitle.textContent = "æ–°è¦å“";
				extbar.style.display = "none";

				fName.value = "";
				fNo.value = nextTicketNo();
				fParty.value = 1;
				fSeat.value = defaultSeat;

				const t = nowRounded();
				fIn.value = toHHMM(t);
				fDue.value = toHHMM(addMinutes(t, BASE_MIN));
				fNote.value = "";

				tempOccupied = new Set([defaultSeat]);
				buildSeatPick();
				setTypeUI("unknown");

				dlgDelete.style.display = "none";
				dlg.showModal();
				setTimeout(() => fName.focus(), 0);
			};

			const dueFromInput = (g, hhmm) => {
				if (!hhmm) return dueAt(g);
				const inDate = new Date(g.checkInAt);
				const [h, m] = hhmm.split(":").map(Number);

				const d = new Date(inDate);
				d.setHours(h, m, 0, 0);

				if (d < inDate) d.setDate(d.getDate() + 1);
				return d;
			};

			const updateExtInfo = (g, dueOverrideDate=null) => {
				const now = new Date();
				const due = dueOverrideDate || dueAt(g);
				const rem = Math.floor((due - now) / 60000);
				const elp = elapsedMin(g, now);

				const mRem = document.getElementById("mRem");
				const mElp = document.getElementById("mElp");

				if (mRem) mRem.textContent = rem >= 0 ? `æ®‹${rem}åˆ†` : `è¶…é${Math.abs(rem)}åˆ†`;
				if (mElp) mElp.textContent = `çµŒé${elp}åˆ†`;
			};

			const openEditDialog = (groupId) => {
				const g = groups.find((x) => x.id === groupId);
				if (!g) return;

				editingId = groupId;
				dlgTitle.textContent = "ç·¨é›†";
				extbar.style.display = "block";

				fName.value = (g.name || "");
				fNo.value = Number(g.ticketNo || 0) || "";
				fParty.value = (g.partySize || 1);
				fSeat.value = (g.primarySeat || g.seatId || "BOX1");
				fIn.value = toHHMM(new Date(g.checkInAt));
				fDue.value = toHHMM(dueAt(g));
				fNote.value = (g.note || "");

				tempOccupied = new Set(Array.isArray(g.occupiedSeats) ? g.occupiedSeats : [fSeat.value]);
				tempOccupied.add(fSeat.value);
				buildSeatPick();
				setTypeUI(guestTypeKey(g) || "unknown");

				updateExtInfo(g, dueFromInput(g, fDue.value));

				dlgDelete.style.display = "inline-block";
				dlg.showModal();
			};

			extbar.addEventListener("click", (e) => {
				const btn = e.target.closest("button");
				if (!btn || !editingId) return;

				const g = groups.find((x) => x.id === editingId);
				if (!g) return;

				if (btn.dataset.act === "close"){
					const label = ((g.name || "").trim() ? g.name : "æœªå…¥åŠ›");
					if (!confirm(`ã€Œ${label}ã€ã‚’é€€åº—ã«ã—ã¾ã™ã‹ï¼Ÿ`)) return;
					dlg.close();
					closeGroup(editingId);
					editingId = null;
					return;
				}

				const min = Number(btn.dataset.min || 0);
				if (!min) return;

				const currentDue = dueFromInput(g, fDue.value);
				const newDue = addMinutes(currentDue, min);

				fDue.value = toHHMM(newDue);
				updateExtInfo(g, newDue);
			});

			const rebuildExtendsFromDue = (g, inDate, dueHHMM) => {
				if (!dueHHMM) return;

				const [hh, mm] = dueHHMM.split(":").map(Number);
				const dueDate = new Date(inDate);
				dueDate.setHours(hh, mm, 0, 0);
				if (dueDate < inDate) dueDate.setDate(dueDate.getDate() + 1);

				const baseDue = addMinutes(inDate, BASE_MIN);

				let extMin = Math.max(0, Math.round((dueDate - baseDue) / 60000));
				extMin = Math.round(extMin / 30) * 30;

				const newExt = [];
				let remain = extMin;

				while (remain > 0 && newExt.length < 6){
					const take = Math.min(90, remain);
					newExt.push({ at: nowRounded().toISOString(), min: take });
					remain -= take;
				}
				g.extends = newExt;
			};

			fDue.addEventListener("input", () => {
				if (!editingId) return;
				const g = groups.find((x) => x.id === editingId);
				if (!g) return;
				updateExtInfo(g, dueFromInput(g, fDue.value));
			});

			const saveDialog = () => {
				const name = (fName.value || "").trim();
				const party = Number(fParty.value || 1);
				const primary = fSeat.value;
				const inHHMM = fIn.value;
				const dueHHMM = fDue.value;
				const note = (fNote.value || "").trim();

				const ticketNo = Number(fNo.value || 0);
				if (!ticketNo){
					alert("ä¼ç¥¨Noã‚’å…¥ã‚Œã¦ã­ï¼");
					return;
				}

				const clash = groups.find((x) => x.id !== editingId && Number(x.ticketNo) === ticketNo);
				if (clash && !confirm(`ä¼ç¥¨Noã€Œ${ticketNo}ã€ã¯æ—¢ã«ä½¿ã‚ã‚Œã¦ã‚‹ã‚ˆã€‚é‡è¤‡ã—ã¦ã„ã„ï¼Ÿ`)) return;

				if (!inHHMM){
					alert("å…¥åº—æ™‚é–“ã‚’å…¥ã‚Œã¦ã­ï¼");
					return;
				}

				const inDate = checkInDateFromHHMM(inHHMM);

				if (editingId){
					const g = groups.find((x) => x.id === editingId);
					if (!g) return;

					g.name = name;
					g.ticketNo = ticketNo;
					g.partySize = party;
					g.note = note;

					g.guestType = tempGuestType || "unknown";

					g.primarySeat = primary;
					g.occupiedSeats = Array.from(tempOccupied);
					if (!g.occupiedSeats.includes(primary)) g.occupiedSeats.unshift(primary);

					g.checkInAt = inDate.toISOString();
					if (dueHHMM) rebuildExtendsFromDue(g, inDate, dueHHMM);
				}else{
					const id = uid();
					const occ = Array.from(tempOccupied);
					if (!occ.includes(primary)) occ.unshift(primary);

					const g = normalizeGroup({
						id,
						ticketNo,
						primarySeat: primary,
						occupiedSeats: occ,
						name,
						guestType: tempGuestType || "unknown",
						partySize: party,
						note,
						checkInAt: inDate.toISOString(),
						extends: [],
						checkOutAt: null,
						moves: []
					});

					if (dueHHMM) rebuildExtendsFromDue(g, inDate, dueHHMM);
					groups.push(g);
				}

				saveDay(currentBizDate, groups);
				dlg.close();
				renderAll();
			};


			/* ===== Render (cards / stamps) ===== */
			const displayNameOf = (g) => {
				const nm = (g.name || "").trim();
				return nm ? nm : `No.${Number(g.ticketNo)||""}`;
			};

			const createCard = (g) => {
				const seat = g.primarySeat || g.seatId || "";
				const isBox = isBoxSeat(seat);
				const isCounter = isCounterSeat(seat);

				const card = document.createElement("div");
				card.dataset.id = g.id;

				const now = new Date();
				const inT = toHHMM(new Date(g.checkInAt));
				const dueT = toHHMM(dueAt(g));
				const rem = remainingMin(g, now);

				const displayName = displayNameOf(g);
				const remText = (rem >= 0) ? `æ®‹${rem}åˆ†` : `è¶…é${Math.abs(rem)}åˆ†`;
				const typeText = typeShort(g);

				card.className = "guest-card";
				if (isBox) card.classList.add("is-box");
				if (isCounter) card.classList.add("is-counter");
				if (rem < 0) card.classList.add("is-over");
				else if (rem <= 15) card.classList.add("is-soon");

				card.innerHTML = `
					<div class="card-head">
						<div class="card-dots">â— â— â—</div>
						<div class="card-x">Ã—</div>
					</div>
					<div class="card-body">
						${
							isBox
								? `
									<div class="box-no">${escapeHtml(displayName)}</div>
									<div class="box-time">${inT} - ${dueT}</div>
									<div class="box-rem">${escapeHtml(remText)}</div>
									<div class="box-meta">${escapeHtml(typeText)} / ${Number(g.partySize||0)}å</div>
								`
								: `
									<div class="gc-name">${escapeHtml(displayName)}</div>
									<div class="gc-rem">${escapeHtml(remText)}</div>
									<div class="gc-time">${inT} - ${dueT}</div>
									<div class="gc-meta">${escapeHtml(typeText)} / ${Number(g.partySize||0)}å</div>
								`
						}
					</div>
				`;

				const dots = card.querySelector(".card-dots");
				if (dots){
					dots.addEventListener("pointerdown", (e) => e.stopPropagation());
					dots.addEventListener("click", (e) => e.stopPropagation());
				}

				const open = (ev) => {
					if (isDragging) return;      // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®èª¤çˆ†é˜²æ­¢
					ev.preventDefault();
					ev.stopPropagation();
					openEditDialog(g.id);
				};

				card.addEventListener("click", open);
				card.addEventListener("pointerup", open); // â˜…ã‚¹ãƒãƒ›ä¿é™º

				return card;
			};

			const createStamp = (g) => {
				const st = document.createElement("div");
				st.className = "seat-stamp";
				const nm = displayNameOf(g);
				st.innerHTML = `ğŸ“Œ ${escapeHtml(nm)} <small>${Number(g.partySize||0)}å</small>`;
				st.addEventListener("click", () => openEditDialog(g.id));
				return st;
			};

			const applySingleCardClass = () => {
				["BOX1","BOX2"].forEach(seat => {
					const drop = document.getElementById(`seat-${seat}`);
					if (!drop) return;
					const cards = drop.querySelectorAll(":scope > .guest-card");
					drop.classList.toggle("single-card", cards.length === 1);
				});
			};

			const renderSeats = () => {
				for (const seat of SEATS){
				const drop = document.getElementById(`seat-${seat}`);
				if (drop) drop.innerHTML = "";
			}

			const staying = groups.filter((g) => !g.checkOutAt);

			for (const g of staying){
				const p = g.primarySeat || g.seatId;

				if (p){
					const drop = document.getElementById(`seat-${p}`);
					if (drop) drop.appendChild(createCard(g));
				}

				const occ = Array.isArray(g.occupiedSeats) ? g.occupiedSeats : [];
				for (const s of occ){
					if (!s || s === p) continue;
					const drop = document.getElementById(`seat-${s}`);
					if (drop) drop.appendChild(createStamp(g));
				}
			}

			applySingleCardClass(); // â˜…æœ€å¾Œã«
		};


			/* ===== Archive table ===== */
			const endTimeMs = (g) => (g.checkOutAt ? new Date(g.checkOutAt) : dueAt(g)).getTime();

			const renderTable = () => {
				const q = (search.value || "").trim().toLowerCase();

				const sorted = [...groups].sort((a, b) => {
					const aNo = Number(a.ticketNo);
					const bNo = Number(b.ticketNo);

					const aKey = Number.isFinite(aNo) && aNo > 0 ? aNo : 999999;
					const bKey = Number.isFinite(bNo) && bNo > 0 ? bNo : 999999;

					if (sortByEnd){
						const ad = a.checkOutAt ? 1 : 0;
						const bd = b.checkOutAt ? 1 : 0;
						if (ad !== bd) return ad - bd;

						if (!a.checkOutAt && !b.checkOutAt){
							const t = endTimeMs(a) - endTimeMs(b);
							if (t !== 0) return t;
						}
						return aKey - bKey;
					}
					return aKey - bKey;
				});

				tbody.innerHTML = "";
				let cumPeople = 0;

				const isMobile = window.matchMedia("(max-width: 560px)").matches;

				for (const g of sorted){
					const nm = (g.name || "").trim();
					if (q && !nm.toLowerCase().includes(q)) continue;

					cumPeople += Number(g.partySize || 0);

					const exts = Array.isArray(g.extends) ? g.extends : [];
					const c30 = exts.filter((e) => Number(e.min) === 30).length;
					const c60 = exts.filter((e) => Number(e.min) === 60).length;
					const c90 = exts.filter((e) => Number(e.min) === 90).length;
					const extMin = totalExtMin(g);
					const extText = `30:${c30} 60:${c60} 90:${c90} ï½œ åˆè¨ˆ${extMin}åˆ†`;

					const statusClass = g.checkOutAt ? "row-done" : "row-stay";

					const tr = document.createElement("tr");
					tr.className = statusClass + (isMobile ? " mrow" : "");

					if (isMobile){
						tr.innerHTML = `
							<td class="m-lbl m-no-lbl">No</td>
							<td class="m-val m-no-val">${Number(g.ticketNo) || ""}</td>

							<td class="m-lbl m-cum-lbl">ç´¯è¨ˆ</td>
							<td class="m-val m-cum-val">${cumPeople}</td>

							<td class="m-lbl m-seat-lbl">äººæ•°</td>
							<td class="m-val m-seat-val">${Number(g.partySize || 0)}å</td>

							<td class="m-lbl m-name-lbl">ãŠåå‰</td>
							<td class="m-val m-name-val">${escapeHtml(nm || "æœªå…¥åŠ›")}</td>

							<td class="m-lbl m-in-lbl">å…¥åº—</td>
							<td class="m-val m-in-val">${toHHMM(new Date(g.checkInAt))}</td>

							<td class="m-lbl m-out-lbl">é€€åº—</td>
							<td class="m-val m-out-val">${g.checkOutAt ? toHHMM(new Date(g.checkOutAt)) : toHHMM(dueAt(g))}</td>

							<td class="m-lbl m-ext-lbl">å»¶é•·</td>
							<td class="m-val m-ext-val">${escapeHtml(extText)}</td>
						`;
					}else{
						const seatShown = g.checkOutAt
						? seatLabelForArchive(g)
						: (g.primarySeat || g.seatId || "");

						const status = g.checkOutAt ? "é€€åº—æ¸ˆ" : "æ»åœ¨ä¸­";

						tr.innerHTML = `
							<td class="td-muted">${Number(g.ticketNo) || ""}</td>
							<td class="td-muted">${cumPeople}</td>
							<td class="td-strong">${escapeHtml(seatShown)}</td>
							<td class="td-strong">${escapeHtml(guestTypeLabel(g))}</td>

							<td class="td-wrap">
								${escapeHtml(nm || "æœªå…¥åŠ›")}
								${g.note ? `<div class="td-muted">ğŸ“ ${escapeHtml(g.note)}</div>` : ""} 
							</td>

							<td>${Number(g.partySize || 0)}</td>
							<td>${toHHMM(new Date(g.checkInAt))}</td>
							<td>${g.checkOutAt ? toHHMM(new Date(g.checkOutAt)) : toHHMM(dueAt(g))}</td>
							<td class="td-wrap">${escapeHtml(extText)}</td>
							<td class="${g.checkOutAt ? "td-muted" : "td-strong"}">${status}</td>
						`;
					}

					tr.addEventListener("click", () => openEditDialog(g.id));
					tr.style.cursor = "pointer";
					tbody.appendChild(tr);
				}
			};

			const formatBizDateJP = (bizStr) => {
				const [y, m, d] = bizStr.split("-").map(Number);
				const dt = new Date(y, m - 1, d);
				const w = ["æ—¥","æœˆ","ç«","æ°´","æœ¨","é‡‘","åœŸ"][dt.getDay()];
				return `${y}å¹´${m}æœˆ${d}æ—¥(${w})`;
			};

			const renderStatus = () => {
				const staying = groups.filter((g) => !g.checkOutAt);
				const stayingGroups = staying.length;
				const stayingPeople = staying.reduce((a, g) => a + Number(g.partySize || 0), 0);

				const totalGroups = groups.length;
				const totalPeople = groups.reduce((a, g) => a + Number(g.partySize || 0), 0);

				headerStatus.innerHTML = `
					<div class="hs-date">${formatBizDateJP(currentBizDate)}</div>
					<div class="hs-stats">
						æ»åœ¨ä¸­ <b>${stayingGroups}</b>çµ„<b>${stayingPeople}</b>å
						<span class="hs-sep">ï¼</span>
						ç´¯è¨ˆ <b>${totalGroups}</b>çµ„<b>${totalPeople}</b>å
					</div>
				`;
			};

			const renderAll = () => {
				renderSeats();
				renderTable();
				renderStatus();
			};

			const refreshTick = () => {
				renderAll();
				if (editingId){
					const g = groups.find((x) => x.id === editingId);
					if (g) updateExtInfo(g);
				}
			};


			/* ===== Drag & Drop ===== */
			let isDragging = false;

			const initSortable = () => {
				for (const seat of SEATS){
					const el = document.getElementById(`seat-${seat}`);
					if (!el) continue;

					new Sortable(el, {
						group: "seats",
						animation: 160,
						draggable: ".guest-card",
						handle: ".card-dots",            // â˜…ã“ã‚Œè¿½åŠ ï¼šâ—â—â—ã ã‘ã§ãƒ‰ãƒ©ãƒƒã‚°
						delay: 150,                      // â˜…ã‚¹ãƒãƒ›ã§èª¤ãƒ‰ãƒ©ãƒƒã‚°é˜²æ­¢
						delayOnTouchOnly: true,
						touchStartThreshold: 6,
						onStart: () => { isDragging = true; },
						onEnd: (evt) => {
							const id = evt.item?.dataset?.id;
							const toSeat = evt.to?.id?.replace("seat-","");
							if (id && toSeat) movePrimary(id, toSeat);
							setTimeout(() => { isDragging = false; }, 0);
						}
					});
				}
			};

			// zone ã‚¯ãƒªãƒƒã‚¯ã§æ–°è¦ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ç„¡è¦–ï¼‰
			document.querySelectorAll(".zone").forEach((zone) => {
				zone.addEventListener("click", (e) => {
					if (isDragging) return;
					if (e.target.closest(".guest-card")) return;
					if (e.target.closest(".seat-stamp")) return;
					const seat = zone.dataset.seat;
					if (!seat) return;
					openNewDialog(seat);
				});
			});


			/* ===== Events ===== */
			btnNew.addEventListener("click", () => {
				if (isLoadingDay) return alert("èª­ã¿è¾¼ã¿ä¸­ï¼çµ‚ã‚ã£ã¦ã‹ã‚‰æ–°è¦ã—ã¦ã­ğŸ™");
				openNewDialog("BOX1");
			});

			btnToday.addEventListener("click", () => setBizDate(businessDateFor(new Date())));
			btnPrev.addEventListener("click",  () => setBizDate(addDaysToBizDate(currentBizDate, -1)));
			btnNext.addEventListener("click",  () => setBizDate(addDaysToBizDate(currentBizDate, +1)));

			datePicker.addEventListener("change", () => {
				if (!datePicker.value) return;
				setBizDate(datePicker.value);
			});

			btnSortEnd.addEventListener("click", () => {
				sortByEnd = !sortByEnd;
				btnSortEnd.textContent = sortByEnd ? "å…¥åº—é †ã«æˆ»ã™" : "çµ‚äº†æ™‚é–“é †";
				renderTable();
			});

			search.addEventListener("input", renderTable);

			dlgClose.addEventListener("click", () => dlg.close());
			dlgCancel.addEventListener("click", () => dlg.close());
			dlgSave.addEventListener("click", () => {
				if (isLoadingDay) return alert("èª­ã¿è¾¼ã¿ä¸­ã¯ä¿å­˜ã§ããªã„ã‚ˆğŸ™ï¼ˆæ¶ˆãˆã‚‹äº‹æ•…é˜²æ­¢ï¼‰");
				saveDialog();
			});


			dlgDelete.addEventListener("click", () => {
				if (!editingId) return;
				const g = groups.find((x) => x.id === editingId);
				const label = g ? ((g.name || "").trim() ? g.name : "æœªå…¥åŠ›") : "ã“ã®å“";
				if (!confirm(`ã€Œ${label}ã€ã‚’å‰Šé™¤ã—ã¦ã„ã„ï¼Ÿ\nâ€»ã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“`)) return;

				dlg.close();
				deleteGroup(editingId);
				editingId = null;
			});

			// zone ã‚¯ãƒªãƒƒã‚¯ã§æ–°è¦
			document.querySelectorAll(".zone").forEach((zone) => {
				zone.addEventListener("click", (e) => {
					if (isLoadingDay) return;
					if (e.target.closest(".guest-card")) return;
					if (e.target.closest(".seat-stamp")) return;
					const seat = zone.dataset.seat;
					if (!seat) return;
					openNewDialog(seat);
				});
			});


			/* ===== Init ===== */
			const DEMO = false; // â† ã‚µãƒ³ãƒ—ãƒ«å…¥ã‚ŒãŸã„æ™‚ã ã‘ true

			async function boot(){
				datePicker.value = currentBizDate;

				setLoadingDay(true);
				try{
					groups = await loadDay(currentBizDate);
					normalizeAll();
				} finally {
					setLoadingDay(false);
				}

				initSortable();
				renderAll();
				setInterval(refreshTick, 60 * 1000);

				if (DEMO && groups.length === 0){
					const t = nowRounded();
					groups = [
						normalizeGroup({
							id: uid(),
							ticketNo: 1,
							primarySeat:"BOX3",
							occupiedSeats:["BOX3","C6","C5","C4"],
							name:"",
							guestType:"repeat",
							partySize:8,
							note:"å›£ä½“",
							checkInAt: addMinutes(t,-35).toISOString(),
							extends:[],
							checkOutAt:null,
							moves:[]
						}),
						normalizeGroup({
							id: uid(),
							ticketNo: 2,
							primarySeat:"BOX2",
							occupiedSeats:["BOX2"],
							name:"ä½è—¤",
							guestType:"new",
							partySize:3,
							note:"",
							checkInAt: addMinutes(t,-80).toISOString(),
							extends:[{at:addMinutes(t,-10).toISOString(), min:30}],
							checkOutAt:null,
							moves:[]
						}),
					];
					saveDay(currentBizDate, groups);
					renderAll();
				}
			}
			boot();
		})();
	</script>
</body>
</html>
